#!/usr/bin/env ruby
# frozen_string_literal: true

# TODO: Explain yourself

require 'debouncer'
require 'fileutils'
require 'logger'
require 'pathname'
require 'rb-inotify'
require 'tmpdir'

# Config -----------------------------------------------------------------------
DEBOUNCE_WAIT = ENV.fetch('DEBOUNCE_WAIT') { 60 }.to_i # seconds
WATCH_DIR = ENV.fetch('WATCH_DIR')
SRC_DEST_MAP = {
  "#{ENV.fetch('STAGING_DIR')}/desktop" => ENV.fetch('HI_RES_DIR'),
  "#{ENV.fetch('STAGING_DIR')}/web" => ENV.fetch('LO_RES_DIR'),
}

IMPORT_CMD = %(
  photein \
    --verbose \
    --source %s \
    --dest %s \
    --optimize-for %s
)

FORMAT_GROUPS = [%w(.jpg .dng .heic), %w(.mov .mp4), %w(.png)]

LOGGER = Logger.new($stdout).tap(&:info!)

# Setup ------------------------------------------------------------------------
Thread.abort_on_exception = true
SRC_DEST_MAP.keys.each(&FileUtils.method(:mkdir_p))

mutex = Mutex.new
debouncer = Debouncer.new(DEBOUNCE_WAIT) do |*files|
  SRC_DEST_MAP.keys.each { |dir| FileUtils.ln(files, dir) }
  FileUtils.rm(files + Dir["#{ENV.fetch('STAGING_DIR')}/web/*.DNG"]) # FIXME (ugly hack)
  Dir["#{WATCH_DIR}/**/*"].sort.reverse
    .each { |dir| FileUtils.rmdir(dir) if Dir.empty?(dir) }
  break if debouncer.inspect_params[:threads] > 2 # don't let threads pile up

  mutex.synchronize do
    SRC_DEST_MAP.each do |src, dest|
      system(IMPORT_CMD % [src, dest, src.split('/').last])
    end
  rescue => e
    warn e.message
  end
end.reducer(:+)

# Resume from interruption/failure ---------------------------------------------
debouncer.call unless SRC_DEST_MAP.keys.all?(&Dir.method(:empty?))

Dir["#{WATCH_DIR}/**/*"]
  .select(&File.method(:file?))
  .each { |path| debouncer.call(path) }

# Start ------------------------------------------------------------------------
Thread.new do
  call_debouncer = ->(event) do
    debouncer.call(event.absolute_name)
  rescue => e
    warn e.message
  end

  import_notifier = INotify::Notifier.new
  import_notifier.watch(WATCH_DIR, :close_write, &call_debouncer)

  # NOTE: inotify is not recursive,
  # so subdirectories must be watched separately!
  # (Why do Syncthing folders get special treatment?
  # Because ST works by creating hidden tempfiles and moving them upon completion)
  stfolders, simple_subdirs = Dir["#{WATCH_DIR}/**/*"]
    .select(&File.method(:directory?))
    .partition { |dir| Dir.children(dir).include?('.stfolder') }

  simple_subdirs.each { |dir| import_notifier.watch(dir, :close_write, &call_debouncer) }
  stfolders.each { |dir| import_notifier.watch(dir, :moved_to, &call_debouncer) }

  import_notifier.run
end

Thread.new do
  sync_deletions = ->(event) do
    LOGGER.info("#{event.name} has disappeared!")

    deleted_file   = Pathname(event.absolute_name).expand_path

    sister_file    = if deleted_file.to_s.start_with?(File.expand_path(ENV['HI_RES_DIR']))
                      deleted_file.sub(*ENV.values_at('HI_RES_DIR', 'LO_RES_DIR'))
                    else
                      deleted_file.sub(*ENV.values_at('LO_RES_DIR', 'HI_RES_DIR'))
                    end

    sister_formats = FORMAT_GROUPS.find { |group| group.include?(deleted_file.extname) }

    related_files  = [deleted_file, sister_file]
      .product(sister_formats)
      .map { |file, ext| file.sub_ext(ext) }
      .select(&:file?)

    # (Why mv to tmpdir first? Why not rm straight away?
    # Because rm would recursively trigger this inotify callback.)
    related_files.each { |f| LOGGER.info("deleting #{f.realpath}") }
    FileUtils.mv(related_files, Dir.tmpdir)
    FileUtils.rm(related_files.map { |f| File.join(Dir.tmpdir, f.basename) })
  end

  deletion_notifier = INotify::Notifier.new

  # NOTE: inotify is not recursive,
  # so subdirectories must be watched separately!
  (Dir["#{ENV.fetch('HI_RES_DIR')}/**/*"] + Dir["#{ENV.fetch('LO_RES_DIR')}/**/*"])
    .select(&File.method(:directory?))
    .each { |dir| deletion_notifier.watch(dir, :delete, &sync_deletions) }

  deletion_notifier.run
end.join
