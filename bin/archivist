#!/usr/bin/env ruby
# frozen_string_literal: true

# Parse opts -------------------------------------------------------------------
require 'optparse'

parser = OptionParser.new do |opts|
  opts.version = '0.0.1'
  opts.banner  = <<~BANNER
    Usage: archivist [--version] [-h | --help] [<args>]
  BANNER

  opts.on(
    '-v', '--verbose',
    'print verbose output'
  )

  opts.on(
    '-s SOURCE', '--source=SOURCE',
    'specify the source directory'
  )

  opts.on(
    '-d DESTINATION', '--dest=DESTINATION',
    'specify the destination directory'
  )

  opts.on(
    '-V VOLUME', '--volume=VOLUME',
    'mount a device first (e.g., camera SD card)'
  )

  opts.on(
    '-r', '--recursive',
    'ingest source files recursively'
  )

  opts.on(
    '-k', '--keep',
    'do not delete source files'
  )

  opts.on(
    '-i', '--interactive',
    'ask whether to import each file found'
  )

  opts.on(
    '-n', '--dry-run',
    'perform a "no-op" trial run'
  )

  opts.on(
    '--safe',
    'skip files in use by other processes'
  )

  opts.on(
    '--optimize-for=TARGET', %i[desktop web],
    'compress images/video before importing'
  )
end

begin
  # Why a constant?
  # Can't access local vars inside methods (like #import)
  PARAMS = {}
    .tap { |params| parser.parse!(into: params) }
    .tap { |params| params[:verbose] ||= params[:'dry-run'] }
    .freeze

  %i[source dest].each { |type| raise "no #{type} directory given" if !PARAMS.key?(type) }
rescue => e
  warn(e.message)
  warn(parser.help) if e.is_a?(OptionParser::ParseError)
  exit 1
end

# Core logic -------------------------------------------------------------------
require 'date'
require 'fileutils'
require 'pathname'
require 'io/console'
require 'open3'

require 'mini_exiftool' # fast, but only supports JPG
require 'mini_magick'
require 'streamio-ffmpeg'

puts "mounting #{PARAMS[:volume]}" if PARAMS.key?(:volume) && PARAMS[:verbose]
system("mount #{PARAMS[:volume]}") if PARAMS.key?(:volume)

SRC_DIR        = Pathname.new(PARAMS[:source])
DEST_DIR       = Pathname.new(PARAMS[:dest])
DATE_FORMAT    = '%F_%H%M%S'.freeze
IMPORT_METHOD  = PARAMS[:keep] ? :cp : :mv

begin
  raise "#{PARAMS[:source]}: no such directory" unless SRC_DIR.exist?
  raise "#{PARAMS[:dest]}: no such directory" unless DEST_DIR.exist?

  if Dir.empty?(SRC_DIR)
    puts "unmounting #{PARAMS[:volume]}" if PARAMS.key?(:volume) && PARAMS[:verbose]
    system("umount #{PARAMS[:volume]}") if PARAMS.key?(:volume)
    raise "#{PARAMS[:source]}: no photos or videos found"
  end
rescue => e
  warn(e.message)
  exit 1
end

def import(source_file)
  if PARAMS[:interactive]
    printf "Import #{source_file}? [y/N]"
    return if STDIN.getch.downcase.tap { puts } != 'y'
  end

  if PARAMS[:safe]
    out, _err, status = Open3.capture3("lsof '#{source_file}'")
    cmd, pid = out.lines[1]&.split&.first(2)

    # NOTE: Does non-zero exit status ALWAYS mean file is safe to move/copy?
    if status.to_i == 0
      warn "skipping #{source_file}: file in use by #{cmd} (PID #{pid})"
      return
    end
  end

  timestamp = MiniExiftool.new(source_file).create_date || File.mtime(source_file)
  dest_dir  = DEST_DIR.join(timestamp.strftime('%Y'))
  dest_file = dest_dir.join("#{timestamp.strftime(DATE_FORMAT)}#{source_file.extname.downcase}")
  counter   = resolve_name_collision(dest_file.sub_ext("*#{dest_file.extname}"))
  dest_file = dest_file.sub_ext("#{counter}#{dest_file.extname}")

  FileUtils.mkdir_p(dest_dir) unless PARAMS[:'dry-run']

  return if transcode_video(source_file, dest_file)
  return if optimize_image(source_file, dest_file)

  puts "> #{IMPORT_METHOD} #{source_file} #{dest_file}" if PARAMS[:verbose]
  FileUtils.send(IMPORT_METHOD, source_file, dest_file) unless PARAMS[:'dry-run']
  FileUtils.chmod('-x', dest_file) unless PARAMS[:'dry-run']
end

def resolve_name_collision(collision_glob)
  case Dir[collision_glob].length
  when 0 # if no files found, no biggie
  when 1 # if one file found, WITH OR WITHOUT COUNTER, reset counter to a
    puts 'conflicting timestamp found; adding counter to existing file' if PARAMS[:verbose]
    FileUtils.mv(Dir[collision_glob].first, collision_glob.sub('*', 'a'))
  else # TODO: if multiple files found, rectify them?
  end

  # return the next usable counter
  Dir[collision_glob].max&.slice(/.(?=#{Regexp.escape(collision_glob.extname)})/)&.next
    .tap { |counter| raise 'Unresolved timestamp conflict' unless [*Array('a'..'z'), nil].include?(counter) }
end

def transcode_video(source_file, dest_file)
  return false if !PARAMS[:'optimize-for']
  return false unless %w[.mov .mp4].include?(source_file.extname.downcase)

  video = FFMPEG::Movie.new(source_file.to_s)
  case PARAMS[:'optimize-for']
  when 'desktop'
    return false if video.bitrate < 8388608 # 1MB/s (
  when 'web'
    return false if video.bitrate < 2097152 # 0.25MB/s
  end

  puts "transcoding #{source_file}" if PARAMS[:verbose]
  video.transcode(dest_file.sub_ext('.mp4').to_s, [
    '-map_metadata', '0', # https://video.stackexchange.com/a/26076
    '-movflags',     'use_metadata_tags',
    '-c:v',          'libx264',
    '-crf',          PARAMS[:'optimize-for'] == :desktop ? '28' : '35',
  ]) unless PARAMS[:'dry-run']

  puts "> rm #{source_file}" if PARAMS[:verbose] && !PARAMS[:keep]
  FileUtils.rm(source_file) unless PARAMS[:'dry-run'] || PARAMS[:keep]

  return true
end

def optimize_image(source_file, dest_file)
  return false if PARAMS[:'optimize-for'] != :web

  case source_file.extname.downcase
  when '.jpg', '.png'
    # continue
  when '.dng'
    return true # skip import
  else
    return false # import as normal
  end

  image = MiniMagick::Image.open(source_file)
  return false if image.dimensions.reduce(&:*) < 2097152 # 2MP

  puts "optimizing #{source_file}" if PARAMS[:verbose]
  MiniMagick::Tool::Convert.new do |convert|
    convert << source_file
    convert.colorspace('sRGB')
    convert.define('jpeg:dct-method=float')
    convert.interlace('JPEG')
    convert.quality('85%')
    convert.resize('2097152@>')
    convert.sampling_factor('4:2:0')
    convert << dest_file
  end unless PARAMS[:'dry-run']

  puts "> rm #{source_file}" if PARAMS[:verbose] && !PARAMS[:keep]
  FileUtils.rm(source_file) unless PARAMS[:'dry-run'] || PARAMS[:keep]

  return true
end

SRC_DIR
  .join(PARAMS[:recursive] ? '**' : '')
  .join('*.{dng,DNG,jpg,JPG,png,PNG}')
  .then { |glob| Dir[glob].sort }
  .map { |path| Pathname.new(path) }
  .each(&method(:import))

# Video compression is time-consuming, so save it for last
SRC_DIR
  .join(PARAMS[:recursive] ? '**' : '')
  .join('*.{mp4,MP4,mov,MOV}')
  .then { |glob| Dir[glob].sort }
  .map { |path| Pathname.new(path) }
  .each(&method(:import))

# Cleanup ----------------------------------------------------------------------
unless PARAMS[:keep]
  Dir[SRC_DIR.join('**/')].sort
    .drop(1)
    .reverse_each { |d| Dir.rmdir(d) if Dir.empty?(d) }
end

puts "unmounting #{PARAMS[:volume]}" if PARAMS.key?(:volume) && PARAMS[:verbose]
system("umount #{PARAMS[:volume]}") if PARAMS.key?(:volume)
