#!/usr/bin/env ruby
# frozen_string_literal: true

# Parse opts -------------------------------------------------------------------
require 'optparse'

parser = OptionParser.new do |opts|
  opts.version = '0.0.1'
  opts.banner  = <<~BANNER
    Usage: archivist [--version] [-h | --help] [<args>]
  BANNER

  opts.on(
    '-v', '--verbose',
    'print verbose output'
  )

  opts.on(
    '-s SOURCE', '--source=SOURCE',
    'specify the source directory'
  )

  opts.on(
    '-d DESTINATION', '--dest=DESTINATION',
    'specify the destination directory'
  )

  opts.on(
    '-V VOLUME', '--volume=VOLUME',
    'mount a device first (e.g., camera SD card)'
  )

  opts.on(
    '-r', '--recursive',
    'ingest source files recursively'
  )

  opts.on(
    '-k', '--keep',
    'do not delete source files'
  )

  opts.on(
    '-n', '--dry-run',
    'perform a "no-op" trial run'
  )

  opts.on(
    '--compress-video',
    're-encode video as reduced-filesize mp4'
  )
end

begin
  # Why a constant?
  # Can't access local vars inside methods (like #import)
  PARAMS = {}
    .tap { |params| parser.parse!(into: params) }
    .tap { |params| params[:verbose] ||= params[:'dry-run'] }
    .freeze

  %i[source dest].each { |type| raise "no #{type} directory given" if !PARAMS.key?(type) }
rescue => e
  warn(e.message)
  warn(parser.help) if e.is_a?(OptionParser::ParseError)
  exit 1
end

# Core logic -------------------------------------------------------------------
require 'date'
require 'fileutils'
require 'pathname'

require 'mini_exiftool' # fast, but only supports JPG
require 'streamio-ffmpeg'

puts "mounting #{PARAMS[:volume]}" if PARAMS.key?(:volume) && PARAMS[:verbose]
system("mount #{PARAMS[:volume]}") if PARAMS.key?(:volume)

SRC_DIR       = Pathname.new(PARAMS[:source])
DEST_DIR      = Pathname.new(PARAMS[:dest])
DATE_FORMAT   = '%F_%H%M%S'.freeze
IMPORT_METHOD = PARAMS[:keep] ? :cp : :mv

begin
  raise "#{PARAMS[:source]}: no such directory" unless SRC_DIR.exist?
  raise "#{PARAMS[:dest]}: no such directory" unless DEST_DIR.exist?

  if Dir.empty?(SRC_DIR)
    system("umount #{PARAMS[:volume]}") if PARAMS.key?(:volume)
    raise "#{PARAMS[:source]}: no photos or videos found"
  end
rescue => e
  warn(e.message)
  exit 1
end

def import(source_file)
  ext       = source_file[/(?<=\.)\w+$/]
  timestamp = MiniExiftool.new(source_file).then { |metadata| metadata.create_date || metadata.file_modify_date }
  dest_dir  = DEST_DIR.join(timestamp.strftime('%Y'))
  basename  = timestamp.strftime(DATE_FORMAT)

  FileUtils.mkdir_p(dest_dir) unless PARAMS[:'dry-run']

  counter = resolve_name_collision(dest_dir.join("#{basename}*.#{ext}"))

  if %w[mov mp4].include?(ext.downcase) && PARAMS[:'compress-video']
    video = FFMPEG::Movie.new(source_file)

    if video.bitrate > 2097152 # TODO: This is arbitrary; learn more to make a better-informed decision.
      puts "> ffmpeg -i #{source_file} -c:v libx264 -crf 28 #{dest_dir.join("#{basename}#{counter}.#{ext.downcase}")}" if PARAMS[:verbose]
      video.transcode(
        dest_dir.join("#{basename}#{counter}.mp4").to_s,
        %w(-map_metadata 0 -movflags use_metadata_tags -c:v libx264 -crf 28)
      ) unless PARAMS[:'dry-run']
      FileUtils.rm(source_file) unless PARAMS[:'dry-run']

      return
    end
  end

  puts "> #{IMPORT_METHOD} #{source_file} #{dest_dir.join("#{basename}#{counter}.#{ext.downcase}")}" if PARAMS[:verbose]
  FileUtils.send(IMPORT_METHOD, source_file, dest_dir.join("#{basename}#{counter}.#{ext.downcase}")) unless PARAMS[:'dry-run']
end

def resolve_name_collision(collision_glob)
  case Dir[collision_glob].length
  when 0 # if no files found, no biggie
  when 1 # if one file found, WITH OR WITHOUT COUNTER, reset counter to a
    puts 'conflicting timestamp found; adding counter to existing file' if PARAMS[:verbose]
    FileUtils.mv(Dir[collision_glob].first, collision_glob.sub('*', 'a'))
  else # TODO: if multiple files found, rectify them?
  end

  # return the next usable counter
  Dir[collision_glob].max&.slice(/.(?=#{Regexp.escape(collision_glob.extname)})/)&.next
    .tap { |counter| raise 'Unresolved timestamp conflict' unless [*Array('a'..'z'), nil].include?(counter) }
end

SRC_DIR
  .join(PARAMS[:recursive] ? '**' : '')
  .join('*.{dng,DNG,jpg,JPG}')
  .then { |glob| Dir[glob].sort }
  .each(&method(:import))

# Video compression is time-consuming, so save it for last
SRC_DIR
  .join(PARAMS[:recursive] ? '**' : '')
  .join('*.{mp4,MP4,mov,MOV}')
  .then { |glob| Dir[glob].sort }
  .each(&method(:import))

# Cleanup ----------------------------------------------------------------------
unless PARAMS[:keep]
  Dir[SRC_DIR.join('**/')].sort
    .drop(1)
    .reverse_each { |d| Dir.rmdir(d) if Dir.empty?(d) }
end

system("umount #{PARAMS[:volume]}") if PARAMS.key?(:volume)
