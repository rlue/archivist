#!/usr/bin/env ruby
# frozen_string_literal: true

# Parse opts -------------------------------------------------------------------
require 'optparse'

parser = OptionParser.new do |opts|
  opts.version = '0.0.1'
  opts.banner  = <<~BANNER
    Usage: archivist [--version] [-h | --help] [<args>]
  BANNER

  opts.on(
    '-v', '--verbose',
    'print verbose output'
  )

  opts.on(
    '-s SOURCE', '--source=SOURCE',
    'specify the source directory'
  )

  opts.on(
    '-d DESTINATION', '--dest=DESTINATION',
    'specify the destination directory'
  )

  opts.on(
    '-V VOLUME', '--volume=VOLUME',
    'mount a device first (e.g., camera SD card)'
  )

  opts.on(
    '-r', '--recursive',
    'ingest source files recursively'
  )

  opts.on(
    '-k', '--keep',
    'do not delete source files'
  )

  opts.on(
    '-i', '--interactive',
    'ask whether to import each file found'
  )

  opts.on(
    '-n', '--dry-run',
    'perform a "no-op" trial run'
  )

  opts.on(
    '--compress-video',
    're-encode video as reduced-filesize mp4'
  )
end

begin
  # Why a constant?
  # Can't access local vars inside methods (like #import)
  PARAMS = {}
    .tap { |params| parser.parse!(into: params) }
    .tap { |params| params[:verbose] ||= params[:'dry-run'] }
    .freeze

  %i[source dest].each { |type| raise "no #{type} directory given" if !PARAMS.key?(type) }
rescue => e
  warn(e.message)
  warn(parser.help) if e.is_a?(OptionParser::ParseError)
  exit 1
end

# Core logic -------------------------------------------------------------------
require 'date'
require 'fileutils'
require 'pathname'
require 'io/console'

require 'mini_exiftool' # fast, but only supports JPG
require 'streamio-ffmpeg'

puts "mounting #{PARAMS[:volume]}" if PARAMS.key?(:volume) && PARAMS[:verbose]
system("mount #{PARAMS[:volume]}") if PARAMS.key?(:volume)

SRC_DIR        = Pathname.new(PARAMS[:source])
DEST_DIR       = Pathname.new(PARAMS[:dest])
DATE_FORMAT    = '%F_%H%M%S'.freeze
IMPORT_METHOD  = PARAMS[:keep] ? :cp : :mv
TRANSCODE_OPTS = %w[
  -c:v libx264
  -crf 28
  -map_metadata 0
  -movflags use_metadata_tags
] # https://video.stackexchange.com/a/26076

begin
  raise "#{PARAMS[:source]}: no such directory" unless SRC_DIR.exist?
  raise "#{PARAMS[:dest]}: no such directory" unless DEST_DIR.exist?

  if Dir.empty?(SRC_DIR)
    puts "unmounting #{PARAMS[:volume]}" if PARAMS.key?(:volume) && PARAMS[:verbose]
    system("umount #{PARAMS[:volume]}") if PARAMS.key?(:volume)
    raise "#{PARAMS[:source]}: no photos or videos found"
  end
rescue => e
  warn(e.message)
  exit 1
end

def import(source_file)
  if PARAMS[:interactive]
    printf "Import #{source_file}? [y/N]"
    return if STDIN.getch.downcase.tap { puts } != 'y'
  end

  timestamp = MiniExiftool.new(source_file).create_date || File.mtime(source_file)
  dest_dir  = DEST_DIR.join(timestamp.strftime('%Y'))
  dest_file = dest_dir.join("#{timestamp.strftime(DATE_FORMAT)}#{source_file.extname.downcase}")
  counter   = resolve_name_collision(dest_file.sub_ext("*#{dest_file.extname}"))
  dest_file = dest_file.sub_ext("#{counter}#{dest_file.extname}")

  FileUtils.mkdir_p(dest_dir) unless PARAMS[:'dry-run']

  return if transcode_video(source_file, dest_file)

  puts "> #{IMPORT_METHOD} #{source_file} #{dest_file}" if PARAMS[:verbose]
  FileUtils.send(IMPORT_METHOD, source_file, dest_file) unless PARAMS[:'dry-run']
end

def resolve_name_collision(collision_glob)
  case Dir[collision_glob].length
  when 0 # if no files found, no biggie
  when 1 # if one file found, WITH OR WITHOUT COUNTER, reset counter to a
    puts 'conflicting timestamp found; adding counter to existing file' if PARAMS[:verbose]
    FileUtils.mv(Dir[collision_glob].first, collision_glob.sub('*', 'a'))
  else # TODO: if multiple files found, rectify them?
  end

  # return the next usable counter
  Dir[collision_glob].max&.slice(/.(?=#{Regexp.escape(collision_glob.extname)})/)&.next
    .tap { |counter| raise 'Unresolved timestamp conflict' unless [*Array('a'..'z'), nil].include?(counter) }
end

def transcode_video(source_file, dest_file)
  return false if !PARAMS[:'compress-video']
  return false unless %w[.mov .mp4].include?(source_file.extname.downcase)

  video = FFMPEG::Movie.new(source_file.to_s)
  return false if video.bitrate < 2097152

  puts "> ffmpeg -i #{source_file} -c:v libx264 -crf 28 #{dest_file}" if PARAMS[:verbose]
  video.transcode(dest_file.sub_ext('.mp4').to_s, TRANSCODE_OPTS) unless PARAMS[:'dry-run']

  puts "> rm #{source_file}" if PARAMS[:verbose] && !PARAMS[:keep]
  FileUtils.rm(source_file) unless PARAMS[:'dry-run'] || PARAMS[:keep]

  return true
end

SRC_DIR
  .join(PARAMS[:recursive] ? '**' : '')
  .join('*.{dng,DNG,jpg,JPG,png,PNG}')
  .then { |glob| Dir[glob].sort }
  .map { |path| Pathname.new(path) }
  .each(&method(:import))

# Video compression is time-consuming, so save it for last
SRC_DIR
  .join(PARAMS[:recursive] ? '**' : '')
  .join('*.{mp4,MP4,mov,MOV}')
  .then { |glob| Dir[glob].sort }
  .map { |path| Pathname.new(path) }
  .each(&method(:import))

# Cleanup ----------------------------------------------------------------------
unless PARAMS[:keep]
  Dir[SRC_DIR.join('**/')].sort
    .drop(1)
    .reverse_each { |d| Dir.rmdir(d) if Dir.empty?(d) }
end

puts "unmounting #{PARAMS[:volume]}" if PARAMS.key?(:volume) && PARAMS[:verbose]
system("umount #{PARAMS[:volume]}") if PARAMS.key?(:volume)
