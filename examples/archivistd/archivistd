#!/usr/bin/env ruby
# frozen_string_literal: true

# TODO: Explain yourself

require 'debouncer'
require 'fileutils'
require 'logger'
require 'pathname'
require 'rb-inotify'

# Config -----------------------------------------------------------------------
DEBOUNCE_WAIT = ENV.fetch('DEBOUNCE_WAIT') { 60 }.to_i # seconds
WATCH_DIR = ENV.fetch('WATCH_DIR')
SRC_DEST_MAP = {
  "#{ENV.fetch('STAGING_DIR')}/desktop" => ENV.fetch('HI_RES_DIR'),
  "#{ENV.fetch('STAGING_DIR')}/web" => ENV.fetch('LO_RES_DIR'),
}

IMPORT_CMD = %(
  archivist \
    --verbose \
    --source %s \
    --dest %s \
    --optimize-for %s
)

LOGGER = Logger.new($stdout).tap(&:info!)

# Setup ------------------------------------------------------------------------
Thread.abort_on_exception = true
SRC_DEST_MAP.keys.each(&FileUtils.method(:mkdir_p))

mutex = Mutex.new
debouncer = Debouncer.new(DEBOUNCE_WAIT) do |*files|
  SRC_DEST_MAP.keys.each { |dir| FileUtils.ln(files, dir) }
  FileUtils.rm(files + Dir["#{ENV.fetch('STAGING_DIR')}/web/*.DNG"]) # FIXME (ugly hack)
  Dir["#{WATCH_DIR}/**/*"].sort.reverse
    .each { |dir| FileUtils.rmdir(dir) if Dir.empty?(dir) }
  break if debouncer.inspect_params[:threads] > 2 # don't let threads pile up

  mutex.synchronize do
    SRC_DEST_MAP.each do |src, dest|
      system(IMPORT_CMD % [src, dest, src.split('/').last])
    end
  rescue => e
    warn e.message
  end
end.reducer(:+)

# Resume from interruption/failure ---------------------------------------------
debouncer.call unless SRC_DEST_MAP.keys.all?(&Dir.method(:empty?))

Dir["#{WATCH_DIR}/**/*"]
  .select(&File.method(:file?))
  .each { |path| debouncer.call(path) }

# Start ------------------------------------------------------------------------
Thread.new do
  call_debouncer = ->(event) do
    debouncer.call(event.absolute_name)
  rescue => e
    warn e.message
  end

  import_notifier = INotify::Notifier.new
  import_notifier.watch(WATCH_DIR, :close_write, &call_debouncer)

  # NOTE: inotify is not recursive,
  # so subdirectories must be watched separately!
  # (Why do Syncthing folders get special treatment?
  # Because ST works by creating hidden tempfiles and moving them upon completion)
  stfolders, simple_subdirs = Dir["#{WATCH_DIR}/**/*"]
    .select(&File.method(:directory?))
    .partition { |dir| Dir.children(dir).include?('.stfolder') }

  simple_subdirs.each { |dir| import_notifier.watch(dir, :close_write, &call_debouncer) }
  stfolders.each { |dir| import_notifier.watch(dir, :moved_to, &call_debouncer) }

  import_notifier.run
end

Thread.new do
  sync_deletions = ->(event) do
    deleted_file = Pathname(event.absolute_name).realdirpath
    LOGGER.info("#{deleted_file.basename} has disappeared!")

    source_dir = deleted_file.ascend do |path|
      break :hi_res if path == Pathname(ENV.fetch('HI_RES_DIR')).realdirpath
    end || :lo_res

    sister_file = case source_dir
                  when :hi_res
                    deleted_file.sub(ENV.fetch('HI_RES_DIR'), ENV.fetch('LO_RES_DIR'))
                  when :lo_res
                    deleted_file.sub(ENV.fetch('LO_RES_DIR'), ENV.fetch('HI_RES_DIR'))
                  end

    related_files = case deleted_file.extname
                    when '.jpg', '.dng', '.heic'
                      %w(.jpg .dng .heic)
                        .map { |ext| [deleted_file.sub_ext(ext), sister_file.sub_ext(ext)] }
                        .flatten.select(&:file?)
                    when '.mov', '.mp4'
                      %w(.mov .mp4)
                        .map { |ext| sister_file.sub_ext(ext) }
                        .select(&:file?)
                    when '.png'
                      [sister_file]
                    end

    related_files.each { |f| LOGGER.info("deleting #{f.realpath}") }
    FileUtils.rm_rf(related_files)
  end

  deletion_notifier = INotify::Notifier.new

  # NOTE: inotify is not recursive,
  # so subdirectories must be watched separately!
  (Dir["#{ENV.fetch('HI_RES_DIR')}/**/*"] + Dir["#{ENV.fetch('LO_RES_DIR')}/**/*"])
    .select(&File.method(:directory?))
    .each { |dir| deletion_notifier.watch(dir, :delete, &sync_deletions) }

  deletion_notifier.run
end.join
